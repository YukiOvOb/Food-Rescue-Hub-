name: IAST-style Runtime Security (CI)

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

permissions:
  contents: read

jobs:
  iast_style:
    runs-on: ubuntu-latest
    env:
      # Fallback profile for non-integration compose files.
      SPRING_PROFILES_ACTIVE: test

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Select compose file
        id: compose
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "docker-compose.integration.yml" ]; then
            echo "compose_file=docker-compose.integration.yml" >> "$GITHUB_OUTPUT"
          elif [ -f "docker-compose.yml" ]; then
            echo "compose_file=docker-compose.yml" >> "$GITHUB_OUTPUT"
          elif [ -f "compose.yml" ]; then
            echo "compose_file=compose.yml" >> "$GITHUB_OUTPUT"
          else
            echo "No compose file found."
            exit 1
          fi

      # 1) Start the app locally in CI
      - name: Start app (docker compose)
        shell: bash
        run: |
          set -euo pipefail
          docker compose -f "${{ steps.compose.outputs.compose_file }}" up -d --build
          docker compose -f "${{ steps.compose.outputs.compose_file }}" ps
          docker ps

      # 2) Wait until backend is up (change URL if needed)
      - name: Wait for backend
        shell: bash
        run: |
          set -euo pipefail
          for i in {1..60}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/api/hello || true)
            if [ "$code" = "200" ]; then
              echo "Backend is up!"
              exit 0
            fi
            echo "Waiting... ($i) http_code=$code"
            sleep 2
          done
          echo "Backend did not become ready"
          docker compose -f "${{ steps.compose.outputs.compose_file }}" logs --no-color || true
          exit 1

      # 3) Run basic attack payloads (customize endpoints)
      - name: Run security payloads (basic)
        shell: bash
        run: |
          set +e
          mkdir -p security-out/responses

          # NOTE: Change endpoints to REAL endpoints which accept params.
          # If /api/hello ignores params, these tests won't trigger anything.
          curl -s -i "http://localhost:8080/api/hello?x=' OR '1'='1" | tee security-out/responses/sqli1.txt
          curl -s -i "http://localhost:8080/api/hello?x=1;DROP TABLE users" | tee security-out/responses/sqli2.txt
          curl -s -i "http://localhost:8080/api/hello?name=<script>alert(1)</script>" | tee security-out/responses/xss1.txt
          curl -s -i "http://localhost:8080/api/hello?file=../../etc/passwd" | tee security-out/responses/traversal1.txt

          exit 0

      # 4) Collect runtime logs (auto-detect compose containers)
      - name: Collect service logs
        if: always()
        shell: bash
        run: |
          set +e
          mkdir -p security-out/logs

          # Save compose logs (best overall view)
          docker compose -f "${{ steps.compose.outputs.compose_file }}" logs --no-color > security-out/logs/compose.log 2>&1 || true

          # Also save per-container logs (if possible)
          docker ps --format '{{.Names}}' > security-out/logs/containers.txt || true
          while read -r c; do
            [ -z "$c" ] && continue
            docker logs "$c" > "security-out/logs/${c}.log" 2>&1 || true
          done < security-out/logs/containers.txt

      # 5) Evaluate findings (HIGH-SIGNAL only)
      - name: Evaluate runtime findings (high-signal)
        shell: bash
        run: |
          set -euo pipefail
          echo "Evaluating runtime findings (high-signal only)..."

          # ---- High-signal patterns in LOGS (not generic 'Exception') ----
          # These indicate possible injection, stacktrace leakage, or security failures.
          log_patterns=(
            "SQLSyntaxErrorException"
            "syntax error.*SQL"
            "You have an error in your SQL syntax"
            "ORA-[0-9]{5}"
            "org\\.hibernate\\.exception\\.SQLGrammarException"
            "could not extract ResultSet"
            "PreparedStatement"
            "JDBCException"
            "AccessDeniedException"
            "Invalid CSRF token"
            "Forbidden.*CSRF"
            "path traversal"
            "Directory traversal"
            "java\\.io\\.FileNotFoundException: .*\\.(env|properties|yml|yaml)"
          )

          # ---- High-signal patterns in HTTP RESPONSES ----
          # This catches stack traces or error leakage back to the client.
          resp_patterns=(
            "Exception in thread"
            "Whitelabel Error Page"
            "org\\.springframework\\."
            "java\\.lang\\."
            "at .*\\(.*\\.java:[0-9]+\\)"
            "SQLSyntaxErrorException"
            "You have an error in your SQL syntax"
            "root:x:0:0:"   # /etc/passwd content leak indicator
          )

          found=0

          echo "Scanning LOGS..."
          for p in "${log_patterns[@]}"; do
            if grep -RniE "$p" security-out/logs >/dev/null 2>&1; then
              echo "FOUND in logs: $p"
              grep -RniE "$p" security-out/logs | head -n 20 || true
              found=1
            fi
          done

          echo "Scanning HTTP RESPONSES..."
          for p in "${resp_patterns[@]}"; do
            if grep -RniE "$p" security-out/responses >/dev/null 2>&1; then
              echo "FOUND in responses: $p"
              grep -RniE "$p" security-out/responses | head -n 20 || true
              found=1
            fi
          done

          if [ "$found" -eq 1 ]; then
            echo "High-signal runtime security indicators detected. Failing build."
            exit 1
          fi

          echo "No high-signal runtime indicators detected."

      # 6) Upload evidence
      - name: Upload IAST-style artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: iast-style-runtime-evidence
          path: security-out

      # Cleanup
      - name: Stop containers
        if: always()
        shell: bash
        run: docker compose -f "${{ steps.compose.outputs.compose_file }}" down -v
